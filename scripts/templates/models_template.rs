{# 
    Template file for generating the model specification. 
    Use the generate_models.py script to regenerate.
#}
//! This module provides the hierarchical models used in the encoding and decoding process.
// This file has been automatically generated by Jinja2 via the
// script {{ file }}.
// Please do not change this file by hand.
use crate::{
    activation_functions::{GdnLayer, GdnParameters, IgdnLayer, ReluLayer},
    weight_loader::WeightLoader,
    WeightPrecision,
};
use convolutions_rs::{
    convolutions::ConvolutionLayer, transposed_convolutions::TransposedConvolutionLayer, Padding,
};
{% if debug %}
use log::trace;
{% endif %}
use ndarray::*;

pub type InternalDataRepresentation = Array3<WeightPrecision>;

// A note on the weights:
// Naming convention:
// [architecture]_[coder]_[layer type]_[layer]_[weight type]

/// General model trait for en- and decoding
pub trait CodingModel {
    fn forward_pass(&self, input: &InternalDataRepresentation) -> InternalDataRepresentation;
}

impl CodingModel for ConvolutionLayer<WeightPrecision> {
    fn forward_pass(&self, input: &InternalDataRepresentation) -> InternalDataRepresentation {
        self.convolve(input)
    }
}

impl CodingModel for TransposedConvolutionLayer<WeightPrecision> {
        fn forward_pass(&self, input: &InternalDataRepresentation) -> InternalDataRepresentation {
            self.transposed_convolve(input)
        }
}
    

impl CodingModel for GdnLayer {
    fn forward_pass(&self, input: &InternalDataRepresentation) -> InternalDataRepresentation {
        self.activate(input)
    }
}

impl CodingModel for IgdnLayer {
    fn forward_pass(&self, input: &InternalDataRepresentation) -> InternalDataRepresentation {
        self.activate(input)
    }
}

impl CodingModel for ReluLayer {
    fn forward_pass(&self, input: &InternalDataRepresentation) -> InternalDataRepresentation {
        self.activate(input)
    }
}

{% for m in models %} 
    pub struct {{m.rust_name}} {
        {% for l in m.layers %}
            {{l.python_name}}{{l.number}}: {{l.rust_declaration}},
        {% endfor %}
    }

    impl CodingModel for {{m.rust_name}} {
        {# Have to allow since the last let might be extraneous due to model generation #}
        #[allow(clippy::let_and_return)]
        fn forward_pass(&self, input: &InternalDataRepresentation) -> InternalDataRepresentation {
            let x = input.clone();
            {% if debug %}
                trace!("input: {:?}\n", x);
            {% endif %}
            {% for l in m.layers %}
                let x = self.{{l.python_name}}{{l.number}}.forward_pass(&x);
                {% if debug %}
                    trace!("{{m.python_name}}_{{l.python_name}}{{l.number}}_output: {:?}\n", x);
                {% endif %}
            {% endfor %}
            x
        }
    }

    impl {{m.rust_name}} {
        pub fn new(loader: &mut impl WeightLoader) -> Self {
            {% for l in m.layers %}
                {% for w in l.weights %}
                    {% if w is not none %}
                        {% set weight_key = m.python_name + "." + l.python_name + l.number|string + "." + w.name + ".npy" %}
                        let {{ l.python_name }}{{l.number}}_{{w.name}} = loader.get_weight("{{weight_key}}",
                            {{ w.shape }}
                        ).unwrap();
                        {% if debug %}
                            trace!("{{weight_key}}: {:?}\n", {{l.python_name}}{{l.number}}_{{w.name}});
                        {% endif %}
                    {% endif %}
                {% endfor %}
                let {{l.python_name}}{{l.number}} = {{l.rust_name}}::new(
                    {% for w in l.weights %}
                        {% if w is not none %}
                            {{ l.python_name }}{{l.number}}_{{w.name}},
                        {% else %}
                            None,
                        {% endif %}
                    {% endfor %}
                    {% for p in l.other_constructor_parameters %}
                    {{p}},
                    {% endfor %}
                );
            {% endfor %}
            Self {
                {% for l in m.layers %}
                    {{l.python_name}}{{l.number}},
                {% endfor %}
            }
        }
    }
{% endfor %}

mod tests {
    #[allow(unused_imports)]
    use crate::weight_loader::NpzWeightLoader;
    #[allow(unused_imports)]
    use super::*;

    {% for m in models %}
    #[test]
    fn smoke_test_{{m.rust_name.lower()}}() {
        let mut loader = NpzWeightLoader::full_loader();
        let _encoder = {{m.rust_name}}::new(&mut loader);
    }
    {% endfor %}
}
