use super::*;
use ndarray::{Array, array, Dimension};
// Template test file for testing the Rust implementation against the Python
// one. This file has been automatically generated by Jinja2 via the 
// script {{ file }}.
// Please do not change this file by hand.

fn arr_allclose<D: Dimension>(arr1: &Array<f64,D>, arr2: &Array<f64,D>) -> bool {
    (arr1 - arr2).map(|x| (*x as f64).abs()).sum() < 1e-9
}

{% for t in random_tests %}
#[test]
fn test_py_implementation_random_arrays_{{t.test_name}}() {
    {% for r in t.random_test_objects %}
        let test_input{{loop.index}} = {{ r.input_arr }};
        let kernel{{loop.index}} = Array::from_shape_vec({{ r.kernel_shape }},
                                           vec!{{ r.kernel }}).unwrap();
        let conv_layer{{loop.index}} = {{t.layer_name}}::new(kernel{{loop.index}}, {{r.stride}}, {{r.padding}});
        let target_output{{loop.index}} = {{ r.output_arr }};
        let current_output{{loop.index}} = conv_layer.{{function}}(&test_input);

        assert!(arr_allclose(current_output{{loop.index}}, target_output{{loop.index}}), 
                "{:?} was not equal to {:?}", current_output{{loop.index}}, target_output{{loop.index}});
    {% endfor %}
}
{% endfor %}
