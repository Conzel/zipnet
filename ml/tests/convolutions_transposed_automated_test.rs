use ml::convolutions::*;
use ml::transposed_convolutions::*;
use ndarray::{array, Array, Array4, Dimension};

// This file has been automatically generated by Jinja2 via the
// script generate_tests_torch.py.
// Please do not change this file by hand.

fn arr_allclose<D: Dimension>(arr1: &Array<f32, D>, arr2: &Array<f32, D>) -> bool {
    (arr1 - arr2).map(|x| (*x as f32).abs()).sum() < 1e-3
}

#[test]
fn test_py_implementation_random_arrays_transpose_convolve() {
    let test_input1 = array![
        [
            [0.23224549, 0.50588505, 0.86441349, 0.02310899],
            [0.45685568, 0.40417363, 0.25985479, 0.09913059],
            [0.79699722, 0.98004136, 0.25103959, 0.11597095],
            [0.72586276, 0.09967188, 0.29483115, 0.22645573]
        ],
        [
            [0.16055934, 0.43114743, 0.90784464, 0.96178347],
            [0.63828966, 0.534928, 0.68839463, 0.58409027],
            [0.75128938, 0.66844715, 0.66343357, 0.46953653],
            [0.46234563, 0.26003667, 0.77429137, 0.328285]
        ]
    ];

    let kernel1: Array4<f32> = Array::from_shape_vec(
        (2, 1, 4, 4),
        vec![
            0.83035486, 0.49730704, 0.99242497, 0.83261124, 0.8848362, 0.11227968, 0.83485613,
            0.38707261, 0.42852716, 0.33262721, 0.92346432, 0.73501345, 0.24397685, 0.79674084,
            0.95016545, 0.21724486, 0.86324733, 0.1932244, 0.51769137, 0.32076064, 0.96737749,
            0.00598922, 0.39202869, 0.24141203, 0.82792129, 0.69460177, 0.75072335, 0.97536332,
            0.24372894, 0.49899355, 0.31899844, 0.49396161,
        ],
    )
    .unwrap();
    let conv_layer1 = TransposedConvolutionLayer::new(kernel1, 1, Padding::Valid);
    let target_output1 = array![[
        [0.33144861, 0.93877232, 2.14995933, 2.42486811, 2.08468199, 1.53176212, 0.32774308],
        [1.29117489, 2.03965926, 3.85752916, 3.88530016, 2.67034006, 1.78802085, 0.51102138],
        [2.56450272, 3.6250782, 6.07848597, 7.38445759, 5.50631523, 3.62270617, 1.3816185],
        [3.25385857, 4.0704174, 7.32123041, 8.86655426, 6.00851917, 3.7842145, 1.57475841],
        [2.3201077, 3.09584594, 6.01488113, 6.52792072, 4.33433342, 2.58699965, 1.0201695],
        [1.07139742, 2.2325058, 4.3328476, 4.63894558, 2.80374193, 2.06971598, 0.74377227],
        [0.28978071, 0.89672804, 1.30699563, 1.32025993, 1.02147603, 0.76641357, 0.21135652]
    ]];
    let current_output1 = conv_layer1.transposed_convolve(&test_input1);

    assert!(
        arr_allclose(&current_output1, &target_output1),
        "{:?} was not equal to {:?}",
        current_output1,
        target_output1
    );

    let test_input2 = array![
        [
            [0.11416891, 0.68334946, 0.59653256, 0.12978615],
            [0.10638801, 0.1116066, 0.80415186, 0.28193729],
            [0.09670109, 0.17522074, 0.30331546, 0.39188403],
            [0.99324827, 0.44458251, 0.56043957, 0.07845372]
        ],
        [
            [0.09437273, 0.2022228, 0.30105924, 0.18510874],
            [0.50315732, 0.87208086, 0.63173667, 0.97677081],
            [0.2187118, 0.70001813, 0.39591292, 0.73465172],
            [0.00274565, 0.90799466, 0.22369012, 0.68718668]
        ]
    ];

    let kernel2: Array4<f32> = Array::from_shape_vec(
        (2, 1, 4, 4),
        vec![
            0.65592413, 0.66829443, 0.57882502, 0.55727569, 0.17275229, 0.35462692, 0.07000257,
            0.35331661, 0.61658299, 0.30442452, 0.54720806, 0.27519759, 0.7739332, 0.43991743,
            0.05888736, 0.2155859, 0.32379033, 0.42484936, 0.80078561, 0.16511487, 0.96516041,
            0.6095338, 0.78007901, 0.213527, 0.68177587, 0.20005976, 0.52148439, 0.56371771,
            0.81873294, 0.34419013, 0.70609356, 0.46725456,
        ],
    )
    .unwrap();
    let conv_layer2 = TransposedConvolutionLayer::new(kernel2, 1, Padding::Valid);
    let target_output2 = array![[
        [0.10544312, 0.63009578, 1.17300916, 1.30831325, 1.16595459, 0.60549837, 0.10289087],
        [0.34350771, 1.05167973, 2.48243189, 3.07452583, 2.501019, 1.92635369, 0.40377748],
        [0.77298731, 2.31738091, 3.62573767, 5.12469482, 3.61196852, 2.75166821, 0.78793538],
        [1.45444465, 3.69763303, 5.40806723, 6.95630741, 4.5571723, 3.38587093, 1.19519675],
        [0.87726128, 2.98591781, 3.76318431, 6.09720755, 3.47810674, 2.86637449, 1.21361589],
        [0.86819875, 2.02264524, 2.39704466, 3.52603173, 2.30642176, 1.47380984, 0.83672363],
        [0.7709558, 1.52537465, 1.18541622, 1.82960212, 0.98209536, 0.71518111, 0.33800462]
    ]];
    let current_output2 = conv_layer2.transposed_convolve(&test_input2);

    assert!(
        arr_allclose(&current_output2, &target_output2),
        "{:?} was not equal to {:?}",
        current_output2,
        target_output2
    );

    let test_input3 = array![
        [
            [0.23119005, 0.96067435, 0.29916614, 0.6806969],
            [0.91396963, 0.97284102, 0.01715484, 0.04093061],
            [0.4275515, 0.19486532, 0.25447013, 0.08197373],
            [0.6507138, 0.21445233, 0.11806071, 0.17637333]
        ],
        [
            [0.32952575, 0.59583681, 0.17714995, 0.77400486],
            [0.63882513, 0.25830766, 0.21258484, 0.3401532],
            [0.96206266, 0.62044975, 0.28326757, 0.20731905],
            [0.83910975, 0.63256076, 0.05410179, 0.97274446]
        ]
    ];

    let kernel3: Array4<f32> = Array::from_shape_vec(
        (2, 1, 4, 4),
        vec![
            0.74869779, 0.12974854, 0.79447089, 0.53723675, 0.69576324, 0.82454912, 0.37664894,
            0.67223724, 0.50744606, 0.7913009, 0.78958918, 0.64517467, 0.35058063, 0.22394987,
            0.14626299, 0.05523287, 0.46869732, 0.7351389, 0.07301666, 0.27983864, 0.10655331,
            0.9756451, 0.05932388, 0.77344522, 0.61317027, 0.08217912, 0.553476, 0.21154444,
            0.19400314, 0.16894332, 0.94862154, 0.92018245,
        ],
    )
    .unwrap();
    let conv_layer3 = TransposedConvolutionLayer::new(kernel3, 1, Padding::Valid);
    let target_output3 = array![[
        [0.32753932, 1.27076566, 1.07741833, 2.0646081, 1.59078193, 0.80760562, 0.58229184],
        [1.17966819, 2.68166137, 2.90846515, 3.59317803, 3.42571235, 0.76648784, 1.17341769],
        [1.79437029, 4.34355307, 4.12002563, 5.25384569, 3.58502722, 1.70414746, 0.995565],
        [2.28094077, 4.63879919, 5.18298769, 6.55483055, 4.09154367, 2.01300335, 1.43060899],
        [1.79337442, 3.17231703, 3.60327935, 4.09696531, 3.03438711, 1.17414796, 1.28293765],
        [1.18125379, 1.52752757, 2.56078267, 3.60036039, 1.55584753, 1.2486378, 0.51486933],
        [0.3909176, 0.48539084, 1.09795213, 1.72563052, 0.86634362, 1.00486755, 0.90484399]
    ]];
    let current_output3 = conv_layer3.transposed_convolve(&test_input3);

    assert!(
        arr_allclose(&current_output3, &target_output3),
        "{:?} was not equal to {:?}",
        current_output3,
        target_output3
    );
}
